     1                                  ; Se dau doua siruri de octeti s1 si s2. Sa se construiasca sirul de octeti d, care contine pentru fiecare octet din s2 pozitia sa in s1, sau 0 in caz contrar.
     2                                  ;   Exemplu:
     3                                  ;   pos: 1, 2, 3, 4, 5 
     4                                  ;   s1: 7, 33, 55, 19, 46
     5                                  ;   s2: 33, 21, 7, 13, 27, 19, 55, 1, 46 
     6                                  ;   d: 2,  0, 1, 0, 0, 4, 3, 0, 5
     7                                  bits 32
     8                                  global start
     9                                  
    10                                  extern exit
    11                                  import exit msvcrt.dll
    12                                  
    13                                  segment data use32 class=data
    14 00000000 072137132E                  s1 db 7, 33, 55, 19, 46
    15                                      lena equ $-s1
    16 00000005 2115070D1B1337012E          s2 db 33, 21, 7, 13, 27, 19, 55, 1, 46 
    17                                      lenb equ $-s2
    18 0000000E 00<rept>                    d times lenb db 0
    19                                      
    20                                  segment code use32 class=code
    21                                      start:
    22 00000000 B909000000                      mov ecx, lenb        ; ciclul se executa de lenb ori
    23 00000005 E338                            jecxz final         ; prevenim intrarea intr-un ciclu infinit
    24                                  
    25 00000007 FC                              cld                 ; DF = 0
    26 00000008 BE00000000                      mov esi, 0         
    27 0000000D BF[00000000]                    mov edi, s1        ; EDI = offset-ul primului element al sirului s1
    28                                      
    29                                          repeta:
    30 00000012 51                                  push ecx      ; salvam valoarea lui ecx in stiva
    31                                     
    32 00000013 8A86[05000000]                      mov al, [s2+esi] ; punem elemnetele din s2 in al
    33                                   
    34 00000019 B905000000                          mov ecx, lena  ; executam 
    35 0000001E B300                                mov bl, 0
    36                                          
    37                                          gasire:
    38 00000020 FEC3                                inc bl
    39 00000022 AE                                  scasb
    40 00000023 740B                                je amgasit
    41 00000025 E2F9                                loop gasire 
    42                                      
    43 00000027 C686[0E000000]00                mov byte [d+esi],0
    44                                      
    45 0000002E EB06                            jmp peste
    46                                          amgasit:
    47 00000030 889E[0E000000]                  mov [d+esi], bl
    48                                          peste:
    49 00000036 BF[00000000]                    mov edi, s1
    50 0000003B 46                              inc esi
    51 0000003C 59                              pop ecx
    52 0000003D E2D3                            loop repeta
    53                                      final:
    54 0000003F 6A00                        push dword 0
    55 00000041 FF15[00000000]              call [exit]

     1                                  ; Se da un sir de cuvinte s. Sa se construiasca sirul de octeti d, astfel incat d sa contina pentru fiecare pozitie din s:
     2                                      ; - numarul de biti de 0, daca numarul este negativ
     3                                      ; - numarul de biti de 1, daca numarul este pozitiv
     4                                  bits 32
     5                                  global start
     6                                  
     7                                  extern exit
     8                                  import exit msvcrt.dll
     9                                  
    10                                  segment data use32 class=data
    11 00000000 EAFF9100D0FF7F00            s dw -22, 145, -48, 127
    12                                      len equ ($-s)/2
    13 00000008 00<rept>                    d times len db 0
    14 0000000C 1000                        saispe dw 16d
    15                                      
    16                                  segment code use32 class=code
    17                                      start:
    18 00000000 B904000000                      mov ecx, len            ; ECX = lungimea sirului s
    19 00000005 E33D                            jecxz final
    20 00000007 FC                              cld                             ; DF = 0
    21 00000008 BE[00000000]                    mov esi, s                ; ESI = offset-ul lui s
    22 0000000D BF[08000000]                    mov edi, d                ; EDI = offset-ul lui d
    23                                      
    24                                      repeta:
    25 00000012 51                                  push ecx    
    26 00000013 66AD                                lodsw                   ; AX = DS:ESI
    27 00000015 66BB0000                            mov bx, 0               
    28 00000019 B910000000                          mov ecx, 16d      ; ECX = 16 (deoarece facem 16 decrementari)
    29 0000001E 6689C2                              mov dx, ax          ; facem o copie la AX in DX
    30                                              
    31                                              numara
    31          ******************       warning: label alone on a line without a colon might be in error [-w+orphan-labels]
    32 00000021 66D1E8                                  shr ax, 1            ; shift-right pe pentru a ne da carry-flag
    33 00000024 6683D300                                adc bx, 0           ; adaugam carryflag-ul in BX
    34 00000028 E2F7                                loop numara   
    35                                              
    36 0000002A 6683FA00                            cmp dx, 0               ; comparam DX cu 0 
    37 0000002E 790D                                jns pozitiv                ; daca valoarea din DX este pozitiva facem jump la eticheta "pozitiv"
    38                                              
    39 00000030 668B15[0C000000]                    mov dx, [saispe]    ; facem o scadere din 16 pentru a afla numarul de zerouri
    40 00000037 6629DA                              sub dx, bx
    41 0000003A 6689D3                              mov bx, dx
    42                                              
    43                                              pozitiv:
    44                                              
    45 0000003D 6689D8                              mov ax, bx
    46 00000040 AA                                  stosb                   ; ES : EDI = AX
    47 00000041 59                                  pop ecx      
    48                                          
    49 00000042 E2CE                            loop repeta
    50                                          
    51                                          final:
    52                                          
    53 00000044 6A00                            push dword 0
    54 00000046 FF15[00000000]                  call [exit]
